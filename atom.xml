<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米斯特周</title>
  
  <subtitle>米斯特周</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cczjh.github.io/"/>
  <updated>2021-08-04T08:13:39.294Z</updated>
  <id>https://cczjh.github.io/</id>
  
  <author>
    <name>Zhou_jh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git项目管理</title>
    <link href="https://cczjh.github.io/2021/08/04/git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>https://cczjh.github.io/2021/08/04/git项目管理/</id>
    <published>2021-08-04T07:48:44.000Z</published>
    <updated>2021-08-04T08:13:39.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实最基本的流程就是新建分支，在这个分支上改动代码，再提交上去，跟master分支合并。</p><h3 id="1-新建分支"><a href="#1-新建分支" class="headerlink" title="1. 新建分支"></a>1. 新建分支</h3><p>首先，在你新建分支之前，你应该在master分支，并且要保证你当前的是最新代码，要不然就是找死，最后提交代码就会出问题。</p><pre><code>1. &lt;font color=#4ac3dfdb&gt;git pull origin master&lt;/font&gt; ，在master分支下，保证当前代码与线上同步，是最新的2. &lt;font color=#4ac3dfdb&gt;git branch &lt;分支名&gt;&lt;/font&gt; ，正儿八经的新建分支。3. &lt;font color=#4ac3dfdb&gt;git checkout &lt;分支名&gt;&lt;/font&gt; ，切换 到新建的分支上，再进行下一步。4. &lt;font color=#4ac3dfdb&gt;git push origin &lt;分支名&gt;&lt;/font&gt; ,把本地分支推到远端，让远端也有一个你的分支，用来后面提交你的代码。</code></pre><p>新建分支并切换到该分支：<font color="#4ac3dfdb">git checkout -b &lt;分支名&gt;</font></p><h3 id="2-提交代码"><a href="#2-提交代码" class="headerlink" title="2. 提交代码"></a>2. 提交代码</h3><p>在新建的分支上写完代码之后，就可以提交代码了。此时应该在你新建的分支上</p><pre><code>1. &lt;font color=#4ac3dfdb&gt;git status&lt;/font&gt; ,查看自己写了哪些东西。2. &lt;font color=#4ac3dfdb&gt;git add .&lt;/font&gt;3. &lt;font color=#4ac3dfdb&gt;git commit -m&lt;/font&gt; ‘本次提交的描述（写自己的话，不要抄我的，哼！）’4. &lt;font color=#4ac3dfdb&gt;git push origin &lt;分支名&gt;&lt;/font&gt; ,push是从本地向远端推代码，也就是把自己写的代码提交上去，像给老师交作业一样。5. 执行完上一步，有可能报错，此时淡定，不认识英语的话在线翻译是干嘛的，大多数时候提示你，本地落后于远端，（意思就是远端比本地多了一些代码，为什么会出现这种情况呢，肯定是你跟别人共用一个分支，他提交了一段代码到远端，所以导致你的本地落后于远端）既然落后了，那就把他更新成最新的呗，   &lt;font color=#4ac3dfdb&gt;git pull --rebase origin 远程分支名&lt;/font&gt;6. 执行完之后，你的代码就跟远端又一样了。并且你的修改仍然在，此时再提交你的代码   &lt;font color=#4ac3dfdb&gt;git push origin &lt;分支名&gt;&lt;/font&gt;</code></pre><h3 id="3-rebase代码"><a href="#3-rebase代码" class="headerlink" title="3.rebase代码"></a>3.rebase代码</h3><p>提交完代码之后需要让测试人员进行测试，若测试没问题，就可以rebase代码，然后上线了。（这一步是保证你要上线的代码是基于最新的master）</p><pre><code>1. &lt;font color=#4ac3dfdb&gt;git pull —rebase origin &lt;分支名&gt;&lt;/font&gt;2. &lt;font color=#4ac3dfdb&gt;git pull —rebase origin master&lt;/font&gt;</code></pre><p>执行这两步的时候都有可能发生冲突，此时你要做的就是解决冲突，再继续提交。</p><pre><code>1. 解决完冲突之后，&lt;font color=#4ac3dfdb&gt;git add .&lt;/font&gt;2. &lt;font color=#4ac3dfdb&gt;git rebase —continue&lt;/font&gt;3. 若此时还有冲突，继续解决，解决完继续执行1，2步。4. 若此时没有报错，&lt;font color=#4ac3dfdb&gt;git push origin &lt;分支名&gt;&lt;/font&gt;；（这一步必须在git pull —rebase origin master成功之后执行）5. 此时若显示，当前分支落后于master分支，则需要强推，&lt;font color=#4ac3dfdb&gt;git push -f origin &lt;分支名&gt;&lt;/font&gt;，若不报错，则rebase成功。</code></pre><p>以上就是一个完整的流程，以下是一些常用的git操作</p><h3 id="4-删除分支"><a href="#4-删除分支" class="headerlink" title="4.删除分支"></a>4.删除分支</h3><p>删除本地分支 ( 切换到master分支之后再删除 )</p><font color="#4ac3dfdb">git branch -d &lt;分支名&gt;</font><p>删除远端分支</p><font color="#4ac3dfdb">git push origin –delete &lt;分支名&gt;</font><h3 id="5-查看本地有哪些分支"><a href="#5-查看本地有哪些分支" class="headerlink" title="5.查看本地有哪些分支"></a>5.查看本地有哪些分支</h3><font color="#4ac3dfdb">git branch</font><h3 id="6-切换分支"><a href="#6-切换分支" class="headerlink" title="6. 切换分支"></a>6. 切换分支</h3><font color="#4ac3dfdb">git checkout &lt;分支名&gt;</font><h3 id="7-如何从远程拉一个分支"><a href="#7-如何从远程拉一个分支" class="headerlink" title="7.如何从远程拉一个分支"></a>7.如何从远程拉一个分支</h3><p>当你跟别人共用一个分支的时候（有时候前端会共用一个分支），如果别人新建了一个分支（此时远端应该已经有了你们要用的分支），你要做的就是把远端的分支拉到自己本地。</p><font color="#4ac3dfdb">git fetch origin &lt;分支名&gt;: &lt;分支名&gt;</font><h3 id="8-合并分支"><a href="#8-合并分支" class="headerlink" title="8.合并分支"></a>8.合并分支</h3><p>如果你基于主分支master新建了分支dev，再基于dev分支新建了一个分支test，在test分支开发完成后，需要将test合并到dev分支上。此时，先用<font color="#4ac3dfdb">git branch</font> 查看自己在哪个分支上，然后<font color="#4ac3dfdb">git checkout dev</font>(切换到需要合并的分支上)，最后<font color="#4ac3dfdb">git merge test</font>（在dev分支上执行这句，意思是将test合并到dev分支上）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="个人" scheme="https://cczjh.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Git" scheme="https://cczjh.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java调用Mysql命令备份数据库</title>
    <link href="https://cczjh.github.io/2020/06/15/Java%E8%B0%83%E7%94%A8Mysql%E5%91%BD%E4%BB%A4%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://cczjh.github.io/2020/06/15/Java调用Mysql命令备份数据库/</id>
    <published>2020-06-15T07:19:59.000Z</published>
    <updated>2020-06-15T07:24:22.870Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><pre><code>backupSql:  username: root  password: root  hostUrl: 127.0.0.1  database: frs  backupUrl: C:\Users\周大帅\Desktop\backupSql\</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>项目中使用Springboot自带的定时器定时备份数据库</p><pre><code>import com.sxis.common.util.TimeUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.io.File;import java.io.IOException;/** * @ClassName: MysqlScheduled * @Description: * @Date: 2020/6/15 13:40 */@Slf4j@Componentpublic class MysqlScheduled {    @Value(&quot;${backupSql.username}&quot;)    String username;    @Value(&quot;${backupSql.password}&quot;)    String password;    @Value(&quot;${backupSql.hostUrl}&quot;)    String hostUrl;    @Value(&quot;${backupSql.database}&quot;)    String database;    @Value(&quot;${backupSql.backupUrl}&quot;)    String backupUrl;    /**     * @Param []     * @Return void     * @Date 2020/6/15 13:41     * @Description  备份数据库     */    @Async(&quot;asyncExecutor&quot;)    @Scheduled(cron=&quot;0 0 5 * * ?&quot;) // 每天凌晨5点执行//    @Scheduled(fixedDelay=1000*120) // 每天凌晨5点执行    public void backupMysql() {        String nowDate = TimeUtil.getNowDate();        File filePath = new File(backupUrl);        if (!filePath.getParentFile().exists()) {            filePath.getParentFile().mkdirs();        }        if (!filePath.exists()) {            filePath.mkdir();        }        // 保存路径        File saveFilePath = new File(filePath.toString() + &quot;/&quot; + nowDate + &quot;frs.sql&quot;);        StringBuilder sqlOrder = new StringBuilder();        sqlOrder.append(&quot;mysqldump&quot;).append(&quot; --opt&quot;).append(&quot; -h&quot;).append(hostUrl);        sqlOrder.append(&quot; --user=&quot;).append(username).append(&quot; --password=&quot;).append(password)                .append(&quot; --lock-all-tables=true&quot;);        sqlOrder.append(&quot; --result-file=&quot;).append(saveFilePath).append(&quot; --default-character-set=utf8 &quot;)                .append(database);        try {            //调用外部执行exe文件的javaAPI            //也可在linux环境中执行            Process process = Runtime.getRuntime().exec(sqlOrder.toString());            if (process.waitFor() == 0) {// 0 表示线程正常终止。                log.info(&quot;备份数据库成功, 路径为: &quot;+saveFilePath);            }        } catch (IOException e) {            log.error(&quot;数据库备份失败~~~~&quot;);        } catch (InterruptedException e) {            log.error(&quot;数据库备份失败~~~~&quot;);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="Mysql" scheme="https://cczjh.github.io/tags/Mysql/"/>
    
      <category term="数据库" scheme="https://cczjh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Springboot集成Redis</title>
    <link href="https://cczjh.github.io/2020/06/10/Springboot%E9%9B%86%E6%88%90Redis/"/>
    <id>https://cczjh.github.io/2020/06/10/Springboot集成Redis/</id>
    <published>2020-06-10T06:16:37.000Z</published>
    <updated>2020-06-15T07:25:03.622Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="首先添加相关依赖"><a href="#首先添加相关依赖" class="headerlink" title="首先添加相关依赖"></a>首先添加相关依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jedis是Redis在java的客户端实现 --&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="配置文件参数"><a href="#配置文件参数" class="headerlink" title="配置文件参数"></a>配置文件参数</h3><pre><code># Redisredis:  hostName: &quot;172.172.21.32&quot;  port: &quot;6379&quot;  password: &apos;&apos;  timeout: 3600  maxIdle: 300  maxTotal: 1000  maxWaitMillis: 1000  minEvictableIdleTimeMillis: 300000  numTestsPerEvictionRun: 1024  timeBetweenEvictionRunsMillis: 30000  testOnBorrow: true  testWhileIdle: true</code></pre><h3 id="Redis单机版"><a href="#Redis单机版" class="headerlink" title="Redis单机版"></a>Redis单机版</h3><pre><code>@Configurationpublic class RedisConfig {    @Value(&quot;${redis.maxIdle}&quot;)    private Integer maxIdle;    @Value(&quot;${redis.maxTotal}&quot;)    private Integer maxTotal;    @Value(&quot;${redis.maxWaitMillis}&quot;)    private Integer maxWaitMillis;    @Value(&quot;${redis.minEvictableIdleTimeMillis}&quot;)    private Integer minEvictableIdleTimeMillis;    @Value(&quot;${redis.numTestsPerEvictionRun}&quot;)    private Integer numTestsPerEvictionRun;    @Value(&quot;${redis.timeBetweenEvictionRunsMillis}&quot;)    private long timeBetweenEvictionRunsMillis;    @Value(&quot;${redis.testOnBorrow}&quot;)    private boolean testOnBorrow;    @Value(&quot;${redis.testWhileIdle}&quot;)    private boolean testWhileIdle;    @Value(&quot;${redis.hostName}&quot;)    String hostName;    @Value(&quot;${redis.port}&quot;)    int port;    @Value(&quot;${redis.password}&quot;)    String password;    @Value(&quot;${redis.timeout}&quot;)    int timeout;    /**     * JedisPoolConfig 连接池     *     * @return     */    @Bean    public JedisPoolConfig jedisPoolConfig() {        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();        // 最大空闲数        jedisPoolConfig.setMaxIdle(maxIdle);        // 连接池的最大数据库连接数        jedisPoolConfig.setMaxTotal(maxTotal);        // 最大建立连接等待时间        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);        // 逐出连接的最小空闲时间 默认1800000毫秒(30分钟)        jedisPoolConfig.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);        // 每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3        jedisPoolConfig.setNumTestsPerEvictionRun(numTestsPerEvictionRun);        // 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1        jedisPoolConfig.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);        // 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个        jedisPoolConfig.setTestOnBorrow(testOnBorrow);        // 在空闲时检查有效性, 默认false        jedisPoolConfig.setTestWhileIdle(testWhileIdle);        return jedisPoolConfig;    }    /**     * 单机版配置     *     * @param @param  jedisPoolConfig     * @param @return     * @return JedisConnectionFactory     * @throws     * @Title: JedisConnectionFactory     */    @Bean    public JedisConnectionFactory JedisConnectionFactory(JedisPoolConfig jedisPoolConfig) {        JedisConnectionFactory JedisConnectionFactory = new JedisConnectionFactory(jedisPoolConfig);        //连接池        JedisConnectionFactory.setPoolConfig(jedisPoolConfig);        //IP地址        JedisConnectionFactory.setHostName(hostName);        //端口号        JedisConnectionFactory.setPort(port);        //如果Redis设置有密码        JedisConnectionFactory.setPassword(password);        //客户端超时时间单位是毫秒        JedisConnectionFactory.setTimeout(timeout);        return JedisConnectionFactory;    }    /**     * RedisTemplate 模板类     */    @Bean    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {        RedisTemplate&lt;Object, Object&gt; template=new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        // 使用Jackson2JsonRedisSerialize 替换默认序列化        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper mapper=new ObjectMapper();        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(mapper);        // 设置value的序列化规则和 key的序列化规则        template.setValueSerializer(jackson2JsonRedisSerializer);        template.setKeySerializer(new StringRedisSerializer());        template.setHashKeySerializer(new StringRedisSerializer());        template.afterPropertiesSet();        return  template;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="https://cczjh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Springboot" scheme="https://cczjh.github.io/tags/Springboot/"/>
    
      <category term="Redis" scheme="https://cczjh.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Vue表单提交时使用Redis进行表单重复提交验证</title>
    <link href="https://cczjh.github.io/2020/06/09/Vue%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%97%B6%E4%BD%BF%E7%94%A8Redis%E8%BF%9B%E8%A1%8C%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E9%AA%8C%E8%AF%81/"/>
    <id>https://cczjh.github.io/2020/06/09/Vue表单提交时使用Redis进行表单重复提交验证/</id>
    <published>2020-06-09T07:42:07.000Z</published>
    <updated>2020-06-15T07:25:18.994Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目中需要后端做一下防止表单重复点击提交功能, 在此简单记录一下demo</p><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>根据网上的一些方案再结合自己项目的实际情况, 使用拦截器在表单提交之前, 在调用相应的接口时, 对应用户生成token值并将值存放进redis中, 然后在提交表单的时候redis进行判断并删除对应token, 因为redis是单线程执行, 所以不会存在在极短的时间内重复请求接口时redis判断有问题的情况</p><h3 id="添加过滤器"><a href="#添加过滤器" class="headerlink" title="添加过滤器"></a>添加过滤器</h3><p>####说明:<br>正常来说是不需要添加这个过滤器的, 但是因为我需要拿到axios传递的JSON类型参数, 而JSON类型参数需要在request流中获取, 但是request.getInputStream() 与 request.getReader() 只能调用一次, 如果我在拦截器中获取了流, 那么在controller中使用@RequestBody注解获取参数时会报错, 所以对应需要将request处理一下</p><pre><code>import com.sxis.common.security.config.MyHttpServletRequestWrapper;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @ClassName: InitFilter * @Description: * @Date: 2020/6/9 14:16 */@Component@Slf4j@WebFilter(urlPatterns = &quot;/*&quot;)public class InitFilter implements Filter {    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        if (!(request instanceof MyHttpServletRequestWrapper)) {            request = new MyHttpServletRequestWrapper(request);        }        filterChain.doFilter(request, response);    }}</code></pre><p>自定义类重写HttpServletRequestWrapper</p><pre><code>import org.apache.commons.compress.utils.IOUtils;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class MyHttpServletRequestWrapper extends HttpServletRequestWrapper {    private final byte[] body;    public MyHttpServletRequestWrapper(HttpServletRequest request) throws IOException {        super(request);        body = IOUtils.toByteArray(super.getInputStream());    }    @Override    public BufferedReader getReader() throws IOException {        return new BufferedReader(new InputStreamReader(getInputStream()));    }    @Override    public ServletInputStream getInputStream() throws IOException {        return new RequestBodyCachingInputStream(body);    }    private class RequestBodyCachingInputStream extends ServletInputStream {        private byte[] body;        private int lastIndexRetrieved = -1;        private ReadListener listener;        public RequestBodyCachingInputStream(byte[] body) {            this.body = body;        }        @Override        public int read() throws IOException {            if (isFinished()) {                return -1;            }            int i = body[lastIndexRetrieved + 1];            lastIndexRetrieved++;            if (isFinished() &amp;&amp; listener != null) {                try {                    listener.onAllDataRead();                } catch (IOException e) {                    listener.onError(e);                    throw e;                }            }            return i;        }        @Override        public boolean isFinished() {            return lastIndexRetrieved == body.length - 1;        }        @Override        public boolean isReady() {            return isFinished();        }        @Override        public void setReadListener(ReadListener listener) {            if (listener == null) {                throw new IllegalArgumentException(&quot;listener cann not be null&quot;);            }            if (this.listener != null) {                throw new IllegalArgumentException(&quot;listener has been set&quot;);            }            this.listener = listener;            if (!isFinished()) {                try {                    listener.onAllDataRead();                } catch (IOException e) {                    listener.onError(e);                }            } else {                try {                    listener.onAllDataRead();                } catch (IOException e) {                    listener.onError(e);                }            }        }        @Override        public int available() throws IOException {            return body.length - lastIndexRetrieved - 1;        }        @Override        public void close() throws IOException {            lastIndexRetrieved = body.length - 1;            body = null;        }    }}</code></pre><p>这样使用request时就能多次获取流而不会报错</p><h3 id="添加拦截器"><a href="#添加拦截器" class="headerlink" title="添加拦截器"></a>添加拦截器</h3><p>拦截器的添加不做详细赘述</p><p>这是表单提交之前调用的接口拦截器</p><pre><code>import com.alibaba.fastjson.JSONObject;import com.sxis.common.redis.util.RedisUtil;import com.sxis.common.util.CommonUtil;import com.sxis.common.util.RequestStreamUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: InPageInterceptor * @Description: * @Date: 2020/6/8 10:44 */@Slf4j@Componentpublic class InPageInterceptor implements HandlerInterceptor {    @Autowired    private RedisUtil redisUtil;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        log.info(&quot;添加token...&quot;);        JSONObject jsonObject = RequestStreamUtil.getJsonByStream(request);        String userId = jsonObject.getString(&quot;userId&quot;);        String resubmitTokenKey = userId + &quot;resubmitToken&quot;;        String resubmitTokenValue = userId + &quot;-&quot; + CommonUtil.createUUID();        redisUtil.set(resubmitTokenKey, resubmitTokenValue, 600);        return true;    }}</code></pre><p>这是表单提交时调用的接口</p><pre><code>import com.alibaba.fastjson.JSONObject;import com.sxis.common.redis.util.RedisUtil;import com.sxis.common.util.RequestStreamUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @ClassName: ResubmitInterceptor * @Description: * @Date: 2020/6/5 9:53 */@Slf4j@Componentpublic class ResubmitInterceptor implements HandlerInterceptor {    @Autowired    private RedisUtil redisUtil;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        log.info(&quot;释放token...&quot;);        JSONObject jsonObject = RequestStreamUtil.getJsonByStream(request);        String userId = jsonObject.getString(&quot;userId&quot;);        String resubmitTokenKey = userId + &quot;resubmitToken&quot;;        if (redisUtil.hasKey(resubmitTokenKey)) {            log.info(&quot;用户正常提交~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);            redisUtil.del(resubmitTokenKey);        } else {            log.info(&quot;请勿重复提交~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;);            return false;        }        return true;    }}</code></pre><p>以下是RequestStreamUtil中的静态方法, 用于获取request流中json格式参数</p><pre><code>/** * @Param [request] * @Return com.alibaba.fastjson.JSONObject * @Date 2020/6/9 15:30 * @Description 获取前端传递的  Request Payload 中的json参数 * 由于request中的inputStream流只能被读取一次 所以此处传递的request是被处理过的request */public static JSONObject getJsonByStream(HttpServletRequest request) {    StringBuilder sb = new StringBuilder();    try(BufferedReader reader = request.getReader();) {        char[]buff = new char[1024];        int len;        while((len = reader.read(buff)) != -1) {            sb.append(buff,0, len);        }    }catch (IOException e) {        e.printStackTrace();    }    JSONObject jsonObject = JSON.parseObject(sb.toString());    return jsonObject;}</code></pre><p>以上就是简单的后端处理表单重复提交demo </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="https://cczjh.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%89%8D%E7%AB%AF/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="数据库" scheme="https://cczjh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://cczjh.github.io/tags/Redis/"/>
    
      <category term="Vue" scheme="https://cczjh.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配数字(整数,小数,正负号)</title>
    <link href="https://cczjh.github.io/2020/05/28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%95%B0%E5%AD%97-%E6%95%B4%E6%95%B0-%E5%B0%8F%E6%95%B0-%E6%AD%A3%E8%B4%9F%E5%8F%B7/"/>
    <id>https://cczjh.github.io/2020/05/28/正则表达式匹配数字-整数-小数-正负号/</id>
    <published>2020-05-28T09:10:29.000Z</published>
    <updated>2020-05-28T09:14:40.469Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>正则表达式匹配数字: </p><pre><code>^-?(([0-9]{0,16}(\.[0-9]{1,2})$)|([0-9]+$))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="https://cczjh.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="form表单" scheme="https://cczjh.github.io/tags/form%E8%A1%A8%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Centos7配置tomcat并设置开机启动(systemctl)</title>
    <link href="https://cczjh.github.io/2020/05/11/Centos7%E9%85%8D%E7%BD%AEtomcat%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8-systemctl/"/>
    <id>https://cczjh.github.io/2020/05/11/Centos7配置tomcat并设置开机启动-systemctl/</id>
    <published>2020-05-11T03:02:10.000Z</published>
    <updated>2020-05-31T01:37:12.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-配置tomcat"><a href="#一-配置tomcat" class="headerlink" title="一. 配置tomcat"></a>一. 配置tomcat</h3><p>从官网下载压缩包:</p><p><a href="https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.tar.gz" title="tomcat9" target="_blank" rel="noopener">https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.tar.gz</a></p><p>解压: </p><pre><code>tar -zxvf apache-tomcat-xxxx.tar.gz </code></pre><p>此处tomcat默认依赖服务器系统配置jdk环境, 不进行配置</p><h3 id="二-配置tomcat自启动"><a href="#二-配置tomcat自启动" class="headerlink" title="二. 配置tomcat自启动"></a>二. 配置tomcat自启动</h3><p>Centos 7 默认使用的是systemctl, 将tomcat配置到systemctl中</p><ol><li><p>在tomcat目录下新建tomcat.pid</p><pre><code>touch tomcat.pid</code></pre></li><li><p>在tomcat/bin目录下新建setenv.sh(catalina.sh调用)</p><pre><code># $CATALINA_BASE为tomcat安装的目录路径,将tomcat.pid指给了CATALINA_PIDCATALINA_PID=&quot;$CATALINA_BASE/tomcat.pid&quot;</code></pre></li><li><p>增加systemctl的tomcat自定义服务, 该目录是systemctl的服务配置目录</p><pre><code>cd /usr/lib/systemd/system</code></pre><p> 新增tomcat服务，写入如下内容:</p><pre><code>vim tomcat.service#[unit]配置了服务的描述，规定了在network启动之后执行。#[service]配置服务的pid，服务的启动，停止，重启。#[install]配置了使用用户。[Unit]Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/home/lianshengcar/tomcat/apache-tomcat-8.0.38/tomcat.pidExecStart=/home/lianshengcar/tomcat/apache-tomcat-8.0.38/bin/startup.shExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre></li><li><p>设置tomcat开机启动</p><pre><code>systemctl enable tomcat</code></pre></li><li><p>启动tomcat测试</p><pre><code>启动 systemctl start   tomcat.service （.service可以省略）状态 systemctl status  tomcat停止 systemctl stop   tomcat重启 systemctl restart tomcat</code></pre><p> 在启动的时候会再tomcat根目录生成tomcat.pid文件, 停止之后删除<br>多个tomcat可以配置在多个目录下, 互不影响, 同时tomcat在启动时候，执行start不会启动两个tomcat, 保证始终只有一个tomcat服务在运行</p></li></ol><h3 id="firewall防火墙开启端口"><a href="#firewall防火墙开启端口" class="headerlink" title="firewall防火墙开启端口"></a>firewall防火墙开启端口</h3><pre><code>// 开启端口firewall-cmd --zone=public --add-port=8080/tcp --permanent// 关闭端口firewall-cmd --zone=public --remove-port=8080/tcp --permanent// 使配置生效firewall-cmd --reload</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="运维" scheme="https://cczjh.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="https://cczjh.github.io/tags/Linux/"/>
    
      <category term="systemctl" scheme="https://cczjh.github.io/tags/systemctl/"/>
    
  </entry>
  
  <entry>
    <title>浏览器下载文件到本地</title>
    <link href="https://cczjh.github.io/2020/05/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%AC%E5%9C%B0/"/>
    <id>https://cczjh.github.io/2020/05/06/浏览器下载文件到本地/</id>
    <published>2020-05-06T07:22:02.000Z</published>
    <updated>2021-08-04T07:50:48.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目中使用到的文件下载方法, 简单记录</p><h4 id="后端主要方法"><a href="#后端主要方法" class="headerlink" title="后端主要方法"></a>后端主要方法</h4><pre><code>@Overridepublic void downloadFile(UploadFile file) { // UploadFile为软件的实体类    HttpServletResponse response = RequestHolder.getResponse();    response.setContentType(&quot;application/x-msdownload&quot;);    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;+file.getFileName());    File fileDownloadPath = new File(file.getFilePath());    if (fileDownloadPath.exists()) {        byte[] buffer = new byte[1024];        FileInputStream fis = null; //文件输入流        BufferedInputStream bis = null;        OutputStream os = null; //输出流        try {            os = response.getOutputStream();            fis = new FileInputStream(fileDownloadPath);            bis = new BufferedInputStream(fis);            int i;            while ((i=bis.read(buffer, 0 , buffer.length)) != -1) {                os.write(buffer, 0, i);                os.flush();            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                bis.close();                fis.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><h4 id="前端主要方法"><a href="#前端主要方法" class="headerlink" title="前端主要方法"></a>前端主要方法</h4><pre><code>// a标签作为点击对象&lt;a class=&quot;downloadA&quot; style=&quot;display: none;&quot;&gt;&lt;/a&gt;// 点击事件downloadFile() {    api.downloadFileRequest(&quot;/file/downloadFile&quot;, {id: this.softwareInfo.uploadFile.id}).then(response =&gt; {      let aUrl = $(&quot;.downloadA&quot;)[0];      let blob = new Blob([response.data]);      // 是否在ie浏览器下载      if (&quot;download&quot; in aUrl) {        aUrl.href = URL.createObjectURL(blob);        aUrl.download = this.softwareInfo.uploadFile.fileName;        aUrl.style.display = &quot;none&quot;;        aUrl.click();        URL.revokeObjectURL(aUrl.href);      } else {        navigator.msSaveBlob(blob, fileName);      }    })  },</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="IO" scheme="https://cczjh.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Springboot使用junit测试</title>
    <link href="https://cczjh.github.io/2020/04/28/Springboot%E4%BD%BF%E7%94%A8junit%E6%B5%8B%E8%AF%95/"/>
    <id>https://cczjh.github.io/2020/04/28/Springboot使用junit测试/</id>
    <published>2020-04-28T06:06:19.000Z</published>
    <updated>2020-04-28T06:15:28.849Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Springboot使用junit测试"><a href="#Springboot使用junit测试" class="headerlink" title="Springboot使用junit测试"></a>Springboot使用junit测试</h3><p>闲话少说, 之前刚用Springboot进行junit测试的时候发现注入的测试类中的 bean 无法被找到, 网上查询了一些资料, 发现是少配置了个注解</p><pre><code>// App 为主启动类@RunWith(SpringRunner.class)@SpringBootTest(classes = App.class)public class Test() {}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="Springboot" scheme="https://cczjh.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot关闭SpringSecurity扫描</title>
    <link href="https://cczjh.github.io/2020/03/02/Springboot%E5%85%B3%E9%97%ADSpringSecurity%E6%89%AB%E6%8F%8F/"/>
    <id>https://cczjh.github.io/2020/03/02/Springboot关闭SpringSecurity扫描/</id>
    <published>2020-03-02T07:38:06.000Z</published>
    <updated>2020-04-28T06:11:28.558Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在springboot启动类中添加：</p><pre><code>@EnableAutoConfiguration(exclude = {SecurityAutoConfiguration.class})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="Springboot" scheme="https://cczjh.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Hexo多电脑编写以及相关Git命令</title>
    <link href="https://cczjh.github.io/2020/01/20/Hexo%E5%A4%9A%E7%94%B5%E8%84%91%E7%BC%96%E5%86%99%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3Git%E5%91%BD%E4%BB%A4/"/>
    <id>https://cczjh.github.io/2020/01/20/Hexo多电脑编写以及相关Git命令/</id>
    <published>2020-01-20T07:40:55.000Z</published>
    <updated>2020-01-20T09:01:50.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现实情况下我们会存在在公司一台电脑, 在家一台电脑的情况. 使用Hexo编写文章, 并将编译过后的页面放在Github库中可以直接访问很方便, 但是由于Hexo的配置等源文件都在电脑本地存放, 所以当想在另一台电脑进行编写文章就无法实现, 在网上查询了一些资料, 挑选了将Hexo源文件也提交到Github库的方法, 并借此学习了一波Git的操作.</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Git: <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><p>Node: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><h3 id="Github仓库准备"><a href="#Github仓库准备" class="headerlink" title="Github仓库准备"></a>Github仓库准备</h3><ul><li>创建分支</li></ul><p>正常情况下, <strong>Github</strong> 库有默认的分支 <strong>master</strong> 这个分支是用来存放 <strong>hexo</strong> 编写文章编译成的页面的. 我们要将 <strong>hexo</strong> 的源文件上传到同一个库中, 所以要先创建一个分支, 此分支用 <strong>source</strong> 命名, 如图, 我之前已经创建过 <strong>scource</strong> 分支</p><p><img src="/2020/01/20/Hexo多电脑编写以及相关Git命令/1.png" alt></p><ul><li>默认分支</li></ul><p><strong>master</strong> 分支是仓库默认分支, 我们要操作的是源文件, 所以需要将默认分支修改为 <strong>source</strong></p><p><img src="/2020/01/20/Hexo多电脑编写以及相关Git命令/2.png" alt></p><h3 id="准备带有Hexo环境的电脑"><a href="#准备带有Hexo环境的电脑" class="headerlink" title="准备带有Hexo环境的电脑"></a>准备带有Hexo环境的电脑</h3><ul><li>将source分支克隆到本地</li></ul><p>首先复制 <strong>Github</strong> 库项目路径</p><p><img src="/2020/01/20/Hexo多电脑编写以及相关Git命令/3.png" alt></p><p>然后在本地创建一个合适文件夹作为存放源文件的路径, 在此文件夹下右键点击 <strong>Git base here</strong> 打开 <strong>Git</strong> 命令行</p><p><img src="/2020/01/20/Hexo多电脑编写以及相关Git命令/4.png" alt></p><p>复制好需要克隆的项目地址, 用如下命令克隆到本地</p><pre><code>git clone https://github.com/xxx // 将项目路径改为你的项目路径</code></pre><ul><li>复制源文件到分支文件夹下</li></ul><p>将 <strong>source</strong> 分支的本地文件夹下的所有文件删除只保留 <strong>.Git</strong> 然后将你平时用以写文章的源文件除了 <strong>.Git</strong> 都复制到 <strong>source</strong> 分支下</p><p><img src="/2020/01/20/Hexo多电脑编写以及相关Git命令/5.png" alt></p><font style="color: red;">注: 如果你的 themes 主题使用的 Github 上的, 文件夹内的 .Git需要删除, git提交不能覆盖提交</font><ul><li>分支提交</li></ul><p>复制好之后, 将分支进行提交</p><pre><code>git add . // 将整个文件夹下代码加入缓冲区git commit -m &quot;注释&quot; // 代码添加注释git push // 项目提交</code></pre><p>查看 <strong>Github</strong> 仓库代码是否已提交完成</p><p><img src="/2020/01/20/Hexo多电脑编写以及相关Git命令/6.png" alt></p><p>到此, 此电脑操作完毕</p><h3 id="新电脑拉取分支"><a href="#新电脑拉取分支" class="headerlink" title="新电脑拉取分支"></a>新电脑拉取分支</h3><ul><li>将source分支克隆到本地</li></ul><p>此处操作和上面一样</p><ul><li>安装依赖 运行测试</li></ul><p>将项目克隆下来之后需要安装依赖, 并运行代码进行测试, 看是否存在问题</p><pre><code>npm install // 安装依赖包</code></pre><p>安装依赖包可能会存在报错, 我这可能是因为之前编译的npm版本不一样, 所以使用上面命令执行结束后让我使用命令 <code>npm audit fix</code>, 执行完就可以了</p><pre><code>// 运行hexo代码hexo cleanhexo ghexo s // 本地运行</code></pre><p>没有报错并且浏览器访问正常, 测试完成.</p><h3 id="修改提交代码"><a href="#修改提交代码" class="headerlink" title="修改提交代码"></a>修改提交代码</h3><p>修改提交代码与第一次提交项目大致命令相同, 但是有一点需要注意, 如果你只提交部分代码 <code>git add .</code> 需要改为 <code>git add *</code>, 不然无法提交</p><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><pre><code>git init // 初始化本地项目git clone xxx // xxx为项目地址  此操作将库中项目克隆到本地git add . git commit -m &quot;注释&quot;git push // 提交代码到仓库git pull // 更新代码到本地git branch -a  // 显示仓库所有分支git checkout 分支名 // 在本地切换当前分支git status // 查看当前项目代码状态git add * // 添加当前路径代码</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="个人" scheme="https://cczjh.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Hexo" scheme="https://cczjh.github.io/tags/Hexo/"/>
    
      <category term="Git" scheme="https://cczjh.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux桥接模式下配置静态ip地址</title>
    <link href="https://cczjh.github.io/2020/01/15/Linux%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip%E5%9C%B0%E5%9D%80/"/>
    <id>https://cczjh.github.io/2020/01/15/Linux桥接模式下配置静态ip地址/</id>
    <published>2020-01-15T01:59:44.000Z</published>
    <updated>2020-04-28T06:10:44.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="桥接模式下配置静态ip"><a href="#桥接模式下配置静态ip" class="headerlink" title="桥接模式下配置静态ip"></a>桥接模式下配置静态ip</h3><h4 id="一、涉及三个文件的配置："><a href="#一、涉及三个文件的配置：" class="headerlink" title="一、涉及三个文件的配置："></a>一、涉及三个文件的配置：</h4><ol><li>/etc/sysconfig/network </li><li>/etc/sysconfig/network-scripts/ifcfg-eth0 </li><li>/etc/resolv.conf</li></ol><h4 id="二、具体配置过程"><a href="#二、具体配置过程" class="headerlink" title="二、具体配置过程"></a>二、具体配置过程</h4><ol><li>ipconfig查看本机ip地址 </li></ol><p><img src="/2020/01/15/Linux桥接模式下配置静态ip地址/1.png" alt></p><hr><pre><code>即本机ip地址为：192.168.1.100网关为：192.168.1.1 子网掩码为：255.255.255.0</code></pre><ol start="2"><li>根据本机ip地址配置linux的静态ip，如下：</li></ol><hr><pre><code>// 进入配置vim /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0        #虚拟机网卡名称。TYPE=EthernetONBOOT=yes　　      #开机启用网络配置。NM_CONTROLLED=yesBOOTPROTO=static      #static，静态ip，而不是dhcp，自动获取ip地址。IPADDR=192.168.1.101　　#设置我想用的静态ip地址，要和物理主机在同一网段，但又不能相同。NETMASK=255.255.255.0  #子网掩码，和物理主机一样就可以了。GETWAY=192.168.1.1     #和本机一样DNS1=8.8.8.8　　　　　　#DNS，写谷歌的地址(免费)。HWADDR=00:oc:29:A5:0D:38IPV6INIT=noUSERCTL=no</code></pre><ol start="3"><li>在网络配置文件 /etc/sysconfig/network 中添加网关地址</li></ol><hr><pre><code>NETWORKING=yesHOSTNAME=localhost.localdemainGATEWAY=192.168.1.1   #网关地址，同物理主机的网关地址</code></pre><ol start="4"><li>配置 /etc/resolv.conf</li></ol><hr><pre><code>nameserver 8.8.8.8</code></pre><ol start="5"><li>重启网卡 </li></ol><hr><pre><code>service network restart </code></pre><h4 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h4><ol><li>测试与本机互ping</li></ol><p>虚拟机ping主机，</p><hr><pre><code>ping 192.168.100</code></pre><p><img src="/2020/01/15/Linux桥接模式下配置静态ip地址/2.png" alt></p><p>主机ping虚拟机 </p><p><img src="/2020/01/15/Linux桥接模式下配置静态ip地址/3.png" alt></p><p>虚拟机ping外网 </p><p><img src="/2020/01/15/Linux桥接模式下配置静态ip地址/4.png" alt></p><h4 id="四、遇到的问题"><a href="#四、遇到的问题" class="headerlink" title="四、遇到的问题"></a>四、遇到的问题</h4><ol><li>按照上述步骤可实现ping通外网和主机ping同虚拟机，但存在虚拟机ping不通主机，主要问题是物理本机的防火墙没有关闭，关闭即可。</li><li>自己配置遇到问题的参考博客： vmware下centOs设置静态IP和无法本地ping通centOs的ip解决方法(<a href="http://blog.csdn.net/shaonaozu/article/details/12869185" target="_blank" rel="noopener">http://blog.csdn.net/shaonaozu/article/details/12869185</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="运维" scheme="https://cczjh.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="https://cczjh.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux iptables防火墙开放端口不生效</title>
    <link href="https://cczjh.github.io/2020/01/10/Linux-iptables%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <id>https://cczjh.github.io/2020/01/10/Linux-iptables防火墙开放端口不生效/</id>
    <published>2020-01-10T06:43:59.000Z</published>
    <updated>2020-01-20T07:29:17.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="iptables常用命令"><a href="#iptables常用命令" class="headerlink" title="iptables常用命令"></a>iptables常用命令</h3><hr><pre><code>service iptables start // 开启iptablesservice iptables stop // 关闭iptablesservice iptables restart // 重启service iptables status // iptables状态service iptables save // 保存iptables配置文件/etc/sysconfig/iptables // iptables规则存放文件</code></pre><h3 id="iptables开放端口"><a href="#iptables开放端口" class="headerlink" title="iptables开放端口"></a>iptables开放端口</h3><h4 id="一"><a href="#一" class="headerlink" title="一."></a>一.</h4><hr><pre><code>// 先使用此命令将需要开放的端口添加进规则内iptables -A INPUT -p tcp --dport 8080 -j ACCEPTiptables -A OUTPUT -p tcp --sport 8080 -j ACCEPT// 保存规则service iptables save// 重启service iptables restart</code></pre><h4 id="二"><a href="#二" class="headerlink" title="二."></a>二.</h4><hr><pre><code>// 编辑iptables规则文件vim /etc/sysconfig/iptables// 添加如下-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT// 重启service iptables restart</code></pre><h3 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h3><p>有时候当进行如上操作时会发现接口任不可访问, 是因为用以上的方式添加接口规则时, 接口默认排在最后, 此时接口规则并不生效, 所以我们应该用iptables -I进行添加, 这样就会将8080接口规则放在首位</p><pre><code>iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code></pre><p><img src="/2020/01/10/Linux-iptables防火墙开放端口不生效/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="运维" scheme="https://cczjh.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="https://cczjh.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient模拟form表单上传文件</title>
    <link href="https://cczjh.github.io/2019/09/25/HttpClient%E6%A8%A1%E6%8B%9Fform%E8%A1%A8%E5%8D%95%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>https://cczjh.github.io/2019/09/25/HttpClient模拟form表单上传文件/</id>
    <published>2019-09-25T02:45:23.000Z</published>
    <updated>2020-01-20T07:29:17.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转: <a href="https://www.cnblogs.com/zdz8207/p/java-httpclient-file.html" title="java模拟表单上传文件，java通过模拟post方式提交表单实现图片上传功能实例" target="_blank" rel="noopener">https://www.cnblogs.com/zdz8207/p/java-httpclient-file.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="HttpClient" scheme="https://cczjh.github.io/tags/HttpClient/"/>
    
      <category term="form表单" scheme="https://cczjh.github.io/tags/form%E8%A1%A8%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 使用 JNA 调用dll/so动态库</title>
    <link href="https://cczjh.github.io/2019/09/18/Java-%E4%BD%BF%E7%94%A8-JNA-%E8%B0%83%E7%94%A8dll-so%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>https://cczjh.github.io/2019/09/18/Java-使用-JNA-调用dll-so动态库/</id>
    <published>2019-09-18T03:08:11.000Z</published>
    <updated>2020-01-20T07:29:17.208Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转: <a href="https://www.jianshu.com/p/272a1efbe027" title="java使用jna调用dll/so动态库" target="_blank" rel="noopener">https://www.jianshu.com/p/272a1efbe027</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="JNA" scheme="https://cczjh.github.io/tags/JNA/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池的技术及优化</title>
    <link href="https://cczjh.github.io/2019/09/04/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>https://cczjh.github.io/2019/09/04/Java线程池的技术及优化/</id>
    <published>2019-09-04T02:57:49.000Z</published>
    <updated>2020-01-20T07:29:17.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="创建线程池的demo"><a href="#创建线程池的demo" class="headerlink" title="创建线程池的demo"></a>创建线程池的demo</h3><pre><code>private static final int POOL_CORE_SIZE = 10; //核心线程数private static final int POOL_MAX_SIZE = 20; //最大线程数private static final int KEEP_ALIVE_TIME = 2000; // 单个线程保活时间(毫秒)private static final int QUEUE_SIZE = 20; //等待队列大小// 创建有界队列BlockingQueue&lt;Runnable&gt; workQueue = new SynchronousQueue&lt;Runnable&gt;(QUEUE_SIZE);// 线程的创建工厂ThreadFactory threadFactory = new ThreadFactory() {    private final AtomicInteger mCount = new AtomicInteger(1);    public Thread newThread(Runnable r) {        return new Thread(r, &quot;AdvacnedAsyncTask #&quot; + mCount.getAndIncrement());    }};// 线程池任务满载后采取的任务拒绝策略RejectedExecutionHandler rejectHandler = new ThreadPoolExecutor.DiscardOldestPolicy();// 线程池对象, 创建线程ThreadPoolExecutor mExecute = new ThreadPoolExecutor(    POOL_CORE_SIZE,    POOL_MAX_SIZE,    KEEP_ALIVE_TIME,    TimeUnit.MILLISECONDS,    workQueue,    threadFactory,    rejectHandler);</code></pre><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><ul><li>corePoolSize：核心线程数，会一直存活，即使没有任务，线程池也会维护线程的最少数量</li><li>maximumPoolSize：线程池维护线程的最大数量</li><li>keepAliveTime：指的是空闲线程结束的超时时间（当一个线程不工作时，过keepAliveTime 长时间将停止该线程）</li><li>allowCoreThreadTimeout：设置为true，则所有线程均会退出直到线程数量为0</li><li>unit：线程池维护线程所允许的空闲时间的单位、可选参数值为：TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS</li><li>workQueue：线程池所使用的缓冲队列，常用的是：java.util.concurrent.ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</li><li>threadFactory：执行程序创建新线程时使用的工厂</li><li>handler：线程池中的数量大于maximumPoolSize，对拒绝任务的处理策略，默认值ThreadPoolExecutor.AbortPolicy()</li></ul><h3 id="参数之间关系如下："><a href="#参数之间关系如下：" class="headerlink" title="参数之间关系如下："></a>参数之间关系如下：</h3><h4 id="第一类："><a href="#第一类：" class="headerlink" title="第一类："></a>第一类：</h4><p>控制被处理线程：corePoolSize，maximumPoolSize，workQueue会决定你的线程处理顺序，首先进来线程会将该线程池的实际线程数变为corePoolSize，达到corePoolsize后，再进来的线程就会进入workQueue来排队；如果workQueue满了，再进来的线程就会继续创建线程，直到实际个数达到maximumPoolSize；</p><p>而关于workQueue有下面三种方式：</p><p>1、直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes， 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p><p>2、无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p><p>3、有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折中：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="线程池" scheme="https://cczjh.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis-持久化数据</title>
    <link href="https://cczjh.github.io/2019/08/13/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE/"/>
    <id>https://cczjh.github.io/2019/08/13/Redis-持久化数据/</id>
    <published>2019-08-13T08:12:55.000Z</published>
    <updated>2020-01-20T07:29:17.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>Redis 提供了多种不同级别的持久化方式：</p><ul><li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li><li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li><li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li><li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul><li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><ul><li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li><li>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h4><ul><li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li><li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h4><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li><li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH source destination timeout 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li></ul><h3 id="RDB-和-AOF-我应该用哪一个"><a href="#RDB-和-AOF-我应该用哪一个" class="headerlink" title="RDB 和 AOF, 我应该用哪一个?"></a>RDB 和 AOF, 我应该用哪一个?</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p><h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。</p><p>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p><p>你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p><p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：</p><pre><code>save 60 1000</code></pre><p>这种持久化方式被称为快照（snapshot）。</p><h3 id="快照的运作方式"><a href="#快照的运作方式" class="headerlink" title="快照的运作方式"></a>快照的运作方式</h3><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ol><li>Redis 调用 fork() ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h3 id="只进行追加操作的文件（append-only-file，AOF）"><a href="#只进行追加操作的文件（append-only-file，AOF）" class="headerlink" title="只进行追加操作的文件（append-only file，AOF）"></a>只进行追加操作的文件（append-only file，AOF）</h3><p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。</p><p>尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。</p><p>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>你可以通过修改配置文件来打开 AOF 功能：</p><pre><code>appendonly yes</code></pre><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET key value [EX seconds] [PX milliseconds] [NX|XX]）， 这个命令就会被追加到 AOF 文件的末尾。</p><p>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</p><p>举个例子， 如果你对一个计数器调用了 100 次 INCR key ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。</p><p>然而在实际上， 只使用一条 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p><p>执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p><p>Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h3 id="AOF-的耐久性如何？"><a href="#AOF-的耐久性如何？" class="headerlink" title="AOF 的耐久性如何？"></a>AOF 的耐久性如何？</h3><p>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。</p><p>有三个选项：</p><ul><li>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li></ul><ul><li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li></ul><ul><li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><p>总是 fsync 的策略在实际使用中非常慢， 即使在 Redis 2.0 对相关的程序进行了改进之后仍是如此 —— 频繁调用 fsync 注定了这种策略不可能快得起来。</p><h3 id="如果-AOF-文件出错了，怎么办？"><a href="#如果-AOF-文件出错了，怎么办？" class="headerlink" title="如果 AOF 文件出错了，怎么办？"></a>如果 AOF 文件出错了，怎么办？</h3><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。</p><p>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p><ol><li>为现有的 AOF 文件创建一个备份。</li><li>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</li></ol><blockquote><p>$ redis-check-aof –fix</p></blockquote><ol start="3"><li>（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</li><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li></ol><h3 id="AOF-的运作方式"><a href="#AOF-的运作方式" class="headerlink" title="AOF 的运作方式"></a>AOF 的运作方式</h3><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</p><p>以下是 AOF 重写的执行步骤：</p><ol><li>Redis 执行 fork() ，现在同时拥有父进程和子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ol><h3 id="怎么从-RDB-持久化切换到-AOF-持久化"><a href="#怎么从-RDB-持久化切换到-AOF-持久化" class="headerlink" title="怎么从 RDB 持久化切换到 AOF 持久化"></a>怎么从 RDB 持久化切换到 AOF 持久化</h3><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：</p><ol><li>为最新的 dump.rdb 文件创建一个备份。</li><li>将备份放到一个安全的地方。</li><li>执行以下两条命令：</li></ol><blockquote><p>redis-cli&gt; CONFIG SET appendonly yes</p></blockquote><blockquote><p>redis-cli&gt; CONFIG SET save “”</p></blockquote><ol start="4"><li>确保命令执行之后，数据库的键的数量没有改变。</li><li>确保写命令会被正确地追加到 AOF 文件的末尾。</li></ol><p>步骤 3 执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</p><p>步骤 3 执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。</p><h3 id="RDB-和-AOF-之间的相互作用"><a href="#RDB-和-AOF-之间的相互作用" class="headerlink" title="RDB 和 AOF 之间的相互作用"></a>RDB 和 AOF 之间的相互作用</h3><p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。</p><p>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p><p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。</p><p>当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p><h3 id="备份-Redis-数据"><a href="#备份-Redis-数据" class="headerlink" title="备份 Redis 数据"></a>备份 Redis 数据</h3><p>在阅读这个小节前， 先将下面这句话铭记于心： 一定要备份你的数据库！</p><p>磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p><p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p><p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p><p>以下是我们的建议：</p><ul><li>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。</li><li>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</li><li>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</li></ul><h3 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h3><p>Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。</p><p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时， 仍然让数据处于安全状态。</p><p>因为很多 Redis 用户都是创业者， 他们没有大把大把的钱可以浪费， 所以下面介绍的都是一些实用又便宜的容灾备份方法：</p><ul><li>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。 最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。 对数据的加密可以通过 gpg -c 命令来完成（对称加密模式）。 记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。 同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</li><li>传送快照可以使用 SCP 来完成（SSH 的组件）。 以下是简单并且安全的传送方法： 买一个离你的数据中心非常远的 VPS ， 装上 SSH ， 创建一个无口令的 SSH 客户端 key ， 并将这个 key 添加到 VPS 的 authorized_keys 文件中， 这样就可以向这个 VPS 传送快照备份文件了。 为了达到最好的数据安全性，至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</li></ul><p>需要注意的是， 这类容灾系统如果没有小心地进行处理的话， 是很容易失效的。</p><p>最低限度下， 你应该在文件传送完毕之后， 检查所传送备份文件的体积和原始快照文件的体积是否相同。 如果你使用的是 VPS ， 那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。</p><p>另外， 你还需要一个独立的警报系统， 让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p><p>转: <a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">http://redisdoc.com/topic/persistence.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="https://cczjh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="https://cczjh.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="https://cczjh.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Springboot自定义连接池并开启定时任务</title>
    <link href="https://cczjh.github.io/2019/06/26/Springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B9%B6%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>https://cczjh.github.io/2019/06/26/Springboot自定义线程池并开启定时任务/</id>
    <published>2019-06-26T09:16:12.000Z</published>
    <updated>2020-01-20T07:29:17.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Springboot自定义线程池"><a href="#Springboot自定义线程池" class="headerlink" title="Springboot自定义线程池"></a>Springboot自定义线程池</h3><h4 id="线程池参数配置"><a href="#线程池参数配置" class="headerlink" title="线程池参数配置"></a>线程池参数配置</h4><hr><pre><code>## 连接池threadPool:  corePoolSize: 20  maxPoolSize: 40  queueCapacity: 1000  # 线程前缀名  threadNamePrefix: &apos;Async-Service-&apos;  allowCoreThreadTimeout: false  keepAliveSeconds: 300</code></pre><h4 id="线程池配置类"><a href="#线程池配置类" class="headerlink" title="线程池配置类"></a>线程池配置类</h4><p>创建一个配置类ExecutorConfig, 用来自定义如何创建一个ThreadPoolTaskExecutor, 在类上添加@Configuration和@EnableAsync注解, 表示是配置类.</p><hr><pre><code>@Configuration@EnableAsyncpublic class ExecutorConfig implements AsyncConfigurer {    private static Logger log = LoggerFactory.getLogger(ExecutorConfig.class);    @Value(&quot;${threadPool.corePoolSize}&quot;)    int corePoolSize;    @Value(&quot;${threadPool.maxPoolSize}&quot;)    int maxPoolSize;    @Value(&quot;${threadPool.queueCapacity}&quot;)    int queueCapacity;    @Value(&quot;${threadPool.threadNamePrefix}&quot;)    String threadNamePrefix;    @Value(&quot;${threadPool.keepAliveSeconds}&quot;)    int keepAliveSeconds;    @Bean(&quot;asyncExecutor&quot;)    public Executor asyncExecutor() {        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        executor.setCorePoolSize(corePoolSize);        executor.setMaxPoolSize(maxPoolSize);        executor.setQueueCapacity(queueCapacity);        executor.setKeepAliveSeconds(keepAliveSeconds);        executor.setThreadNamePrefix(threadNamePrefix);        // 线程池对拒绝任务的处理策略        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        // 初始化        executor.initialize();        return executor;    }    @Override    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {        return new AsyncUncaughtExceptionHandler() {            @Override            public void handleUncaughtException(Throwable ex, Method method, Object... params) {                log.error(&quot;==========================&quot; + ex.getMessage() + &quot;=======================&quot;, ex);                log.error(&quot;exception method:&quot; + method.getName());            }        };    }}</code></pre><h3 id="Springboot开启多线程定时任务"><a href="#Springboot开启多线程定时任务" class="headerlink" title="Springboot开启多线程定时任务"></a>Springboot开启多线程定时任务</h3><p>以下为定时任务类, 定时任务由此定义开启</p><hr><pre><code>@Componentpublic class ComputersTask {    private static Logger log = LoggerFactory.getLogger(ComputersTask.class);    @Autowired    private IemComputerService iemComputerService;    // asyncExecutor 为自定义的线程池    @Async(&quot;asyncExecutor&quot;)    @Scheduled(fixedDelay = 1000 * 60)    public void startListen() throws InterruptedException {        System.out.println(&quot;线程--&quot;+Thread.currentThread().getName()+&quot;--开始!&quot;);        Thread.sleep(1000*10);        System.out.println(&quot;线程--&quot;+Thread.currentThread().getName()+&quot;--结束!&quot;);    }}</code></pre><p>一般情况下, 定时任务默认只使用单线程跑任务, 但在实际开发过程中, 单线程肯定不满足我们的需求, 所以我们需要开启定时任务多线程,<br>因为我们之前有自定义线程池, 所以我们直接在之前的线程池配置类中实现SchedulingConfigurer接口.</p><hr><pre><code>@Configuration@EnableAsync@EnableSchedulingpublic class ExecutorConfig implements AsyncConfigurer, SchedulingConfigurer {    private static Logger log = LoggerFactory.getLogger(ExecutorConfig.class);    @Value(&quot;${threadPool.corePoolSize}&quot;)    int corePoolSize;    @Value(&quot;${threadPool.maxPoolSize}&quot;)    int maxPoolSize;    @Value(&quot;${threadPool.queueCapacity}&quot;)    int queueCapacity;    @Value(&quot;${threadPool.threadNamePrefix}&quot;)    String threadNamePrefix;    @Value(&quot;${threadPool.keepAliveSeconds}&quot;)    int keepAliveSeconds;    @Bean(&quot;asyncExecutor&quot;)    public Executor asyncExecutor() {        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        executor.setCorePoolSize(corePoolSize);        executor.setMaxPoolSize(maxPoolSize);        executor.setQueueCapacity(queueCapacity);        executor.setKeepAliveSeconds(keepAliveSeconds);        executor.setThreadNamePrefix(threadNamePrefix);        // 线程池对拒绝任务的处理策略        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        // 初始化        executor.initialize();        return executor;    }    @Override    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {        return new AsyncUncaughtExceptionHandler() {            @Override            public void handleUncaughtException(Throwable ex, Method method, Object... params) {                log.error(&quot;==========================&quot; + ex.getMessage() + &quot;=======================&quot;, ex);                log.error(&quot;exception method:&quot; + method.getName());            }        };    }        public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {        TaskScheduler taskScheduler = taskScheduler();        scheduledTaskRegistrar.setTaskScheduler(taskScheduler);    }    @Bean(destroyMethod = &quot;shutdown&quot;)    public ThreadPoolTaskScheduler taskScheduler() {        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();        scheduler.setThreadNamePrefix(threadNamePrefix);        scheduler.setPoolSize(corePoolSize);        scheduler.setAwaitTerminationSeconds(60);        scheduler.setWaitForTasksToCompleteOnShutdown(true);        // 线程池对拒绝任务的处理策略        scheduler.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        // 初始化        scheduler.initialize();        return scheduler;    }}</code></pre><p>这样我们的定时任务启动之后就可以多线程运行了.<br><img src="/2019/06/26/Springboot自定义线程池并开启定时任务/p1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="线程池" scheme="https://cczjh.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="Springboot" scheme="https://cczjh.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot配置过滤器拦截器</title>
    <link href="https://cczjh.github.io/2019/05/17/Springboot%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://cczjh.github.io/2019/05/17/Springboot配置过滤器拦截器/</id>
    <published>2019-05-17T01:57:57.000Z</published>
    <updated>2020-06-09T06:25:01.361Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Springboot-配置-Filter过滤器"><a href="#Springboot-配置-Filter过滤器" class="headerlink" title="Springboot 配置 Filter过滤器"></a>Springboot 配置 Filter过滤器</h3><p>上代码:</p><h4 id="1-首先自定义MyFilter-继承类-Filter"><a href="#1-首先自定义MyFilter-继承类-Filter" class="headerlink" title="1. 首先自定义MyFilter 继承类 Filter"></a>1. 首先自定义MyFilter 继承类 Filter</h4><p>我们需要实现做的就是编写doFIlter类实现过滤逻辑</p><pre><code>@Component@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;myFilter&quot;) // 这种是注解配置  下面有配置文件配置public class MyFilter implements Filter {    private static Logger log = LoggerFactory.getLogger(MyFilter.class);    @Override    public void init(FilterConfig filterConfig) throws ServletException {        log.info(&quot;MyFilter参数初始化: &quot;+filterConfig);    }    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        filterChain.doFilter(servletRequest, servletResponse);    }    @Override    public void destroy() {        log.info(&quot;MyFilter开始销毁...&quot;);    }}</code></pre><h4 id="2-在Springboot-启动类中添加过滤器"><a href="#2-在Springboot-启动类中添加过滤器" class="headerlink" title="2. 在Springboot 启动类中添加过滤器"></a>2. 在Springboot 启动类中添加过滤器</h4><pre><code>// 配置文件配置@Beanpublic FilterRegistrationBean testFilterRegistration() {    FilterRegistrationBean registration = new FilterRegistrationBean(new MyFilter());    registration.addUrlPatterns(&quot;/*&quot;);    registration.addInitParameter(&quot;paramName&quot;, &quot;paramValue&quot;);    registration.setName(&quot;myFilter&quot;);    registration.setOrder(1); // 多个过滤器可控制执行顺序 数字越小优先级越高    return registration;}</code></pre><h4 id="3-添加-ServletComponentScan注解"><a href="#3-添加-ServletComponentScan注解" class="headerlink" title="3. 添加@ServletComponentScan注解"></a>3. 添加@ServletComponentScan注解</h4><p>在Springboot启动类中添加@ServletComponentScan注解</p><pre><code>Servlet可以直接通过@WebServlet注解自动注册Filter可以直接通过@WebFilter注解自动注册Listener可以直接通过@WebListener 注解自动注册</code></pre><h3 id="Springboot-配置-拦截器"><a href="#Springboot-配置-拦截器" class="headerlink" title="Springboot 配置 拦截器"></a>Springboot 配置 拦截器</h3><p>上代码:</p><h4 id="1-首先自定义MyInterceptor-实现-WebMvcConfigurer"><a href="#1-首先自定义MyInterceptor-实现-WebMvcConfigurer" class="headerlink" title="1. 首先自定义MyInterceptor 实现 WebMvcConfigurer"></a>1. 首先自定义MyInterceptor 实现 WebMvcConfigurer</h4><pre><code>@Configurationpublic class MyInterceptor implements WebMvcConfigurer {    @Autowired    private ResubmitInterceptor resubmitInterceptor;    /**     * 对所有接口添加/api前缀     */    @Override    public void configurePathMatch(PathMatchConfigurer configurer) {        configurer.addPathPrefix(&quot;/api&quot;,                c -&gt; c.isAnnotationPresent(RestController.class));    }    /**     * 请求验证拦截器     */    @Override    public void addInterceptors(InterceptorRegistry registry) {        /**         * addInterceptor 注册拦截器         * addPathPatterns 配置拦截规则         */        registry.addInterceptor(resubmitInterceptor)                .addPathPatterns(&quot;/**&quot;);    }}</code></pre><h4 id="2-创建拦截器"><a href="#2-创建拦截器" class="headerlink" title="2. 创建拦截器"></a>2. 创建拦截器</h4><pre><code>@Slf4j@Componentpublic class ResubmitInterceptor implements HandlerInterceptor {    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        log.info(&quot;拦截器操作中~~~~~~~~~~~~~~~~~~~~~~&quot;);        return true;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="Springboot" scheme="https://cczjh.github.io/tags/Springboot/"/>
    
      <category term="过滤器" scheme="https://cczjh.github.io/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="拦截器" scheme="https://cczjh.github.io/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mysql主从复制</title>
    <link href="https://cczjh.github.io/2019/05/14/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://cczjh.github.io/2019/05/14/Mysql主从复制/</id>
    <published>2019-05-14T06:07:53.000Z</published>
    <updated>2020-01-20T07:29:17.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Springboot配置日志输出</title>
    <link href="https://cczjh.github.io/2019/05/08/Springboot%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"/>
    <id>https://cczjh.github.io/2019/05/08/Springboot配置日志输出/</id>
    <published>2019-05-08T07:43:27.000Z</published>
    <updated>2020-04-17T03:27:33.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-Springboot配置日志输出"><a href="#一-Springboot配置日志输出" class="headerlink" title="一. Springboot配置日志输出"></a>一. Springboot配置日志输出</h3><h4 id="LockBack的使用"><a href="#LockBack的使用" class="headerlink" title="LockBack的使用"></a>LockBack的使用</h4><p>编写LockBack配置文件, 配置文件需要在application.yml(.properties)中配置</p><pre><code># 配置日志输出# 日志输出logging:      config: classpath:logback-spring.xml      logUrl: D:\工作\workSpace\ideaSpace\SunInfo\log</code></pre><p>我们所需的是 <strong>logback-spring.xml</strong> 配置文件</p><p>该文件在项目结构所在位置如下图:<br><img src="/2019/05/08/Springboot配置日志输出/logback-spring.png" alt></p><p><strong>lobback-spring.xml</strong>配置文件内容如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;&lt;!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --&gt;&lt;!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。             当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;&lt;configuration  scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt;&lt;springProperty scope=&quot;context&quot; name=&quot;logUrl&quot; source=&quot;logging.logUrl&quot;/&gt;&lt;contextName&gt;logback&lt;/contextName&gt;&lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“${}”来使用变量。 --&gt;&lt;property name=&quot;log.path&quot; value=&quot;${logUrl}&quot;/&gt;&lt;!--0. 日志格式和颜色渲染 --&gt;&lt;!-- 彩色日志依赖的渲染类 --&gt;&lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt;&lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt;&lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt;&lt;!-- 彩色日志格式 --&gt;&lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;&lt;!--&lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;%date{yyyy-MM-dd HH:mm:ss} | %highlight(%-5level) | %boldYellow(%thread) | %boldGreen(%logger) | %msg%n&quot;/&gt;--&gt;&lt;!--1. 输出到控制台--&gt;&lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;    &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;    &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;        &lt;level&gt;debug&lt;/level&gt;    &lt;/filter&gt;    &lt;encoder&gt;        &lt;Pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/Pattern&gt;        &lt;!-- 设置字符集 --&gt;        &lt;charset&gt;UTF-8&lt;/charset&gt;    &lt;/encoder&gt;&lt;/appender&gt;&lt;!--2. 输出到文档--&gt;&lt;!-- 2.1 level为 DEBUG 日志，时间滚动输出  --&gt;&lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;    &lt;file&gt;${log.path}/web_debug.log&lt;/file&gt;    &lt;!--日志文档输出格式--&gt;    &lt;encoder&gt;        &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;        &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 设置字符集 --&gt;    &lt;/encoder&gt;    &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;!-- 日志归档 --&gt;        &lt;fileNamePattern&gt;${log.path}/web-debug-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;        &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;        &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;!--日志文档保留天数--&gt;        &lt;maxHistory&gt;15&lt;/maxHistory&gt;    &lt;/rollingPolicy&gt;    &lt;!-- 此日志文档只记录debug级别的 --&gt;    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;        &lt;level&gt;debug&lt;/level&gt;        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;    &lt;/filter&gt;&lt;/appender&gt;&lt;!-- 2.2 level为 INFO 日志，时间滚动输出  --&gt;&lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;    &lt;file&gt;${log.path}/web_info.log&lt;/file&gt;    &lt;!--日志文档输出格式--&gt;    &lt;encoder&gt;        &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;        &lt;charset&gt;UTF-8&lt;/charset&gt;    &lt;/encoder&gt;    &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;!-- 每天日志归档路径以及格式 --&gt;        &lt;fileNamePattern&gt;${log.path}/web-info-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;        &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;        &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;!--日志文档保留天数--&gt;        &lt;maxHistory&gt;15&lt;/maxHistory&gt;    &lt;/rollingPolicy&gt;    &lt;!-- 此日志文档只记录info级别的 --&gt;    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;        &lt;level&gt;info&lt;/level&gt;        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;    &lt;/filter&gt;&lt;/appender&gt;&lt;!-- 2.3 level为 WARN 日志，时间滚动输出  --&gt;&lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;    &lt;file&gt;${log.path}/web_warn.log&lt;/file&gt;    &lt;!--日志文档输出格式--&gt;    &lt;encoder&gt;        &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;        &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;    &lt;/encoder&gt;    &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;fileNamePattern&gt;${log.path}/web-warn-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;        &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;        &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;!--日志文档保留天数--&gt;        &lt;maxHistory&gt;15&lt;/maxHistory&gt;    &lt;/rollingPolicy&gt;    &lt;!-- 此日志文档只记录warn级别的 --&gt;    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;        &lt;level&gt;warn&lt;/level&gt;        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;    &lt;/filter&gt;&lt;/appender&gt;&lt;!-- 2.4 level为 ERROR 日志，时间滚动输出  --&gt;&lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;    &lt;file&gt;${log.path}/web_error.log&lt;/file&gt;    &lt;!--日志文档输出格式--&gt;    &lt;encoder&gt;        &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;        &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;    &lt;/encoder&gt;    &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;fileNamePattern&gt;${log.path}/web-error-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;        &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;        &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;!--日志文档保留天数--&gt;        &lt;maxHistory&gt;15&lt;/maxHistory&gt;    &lt;/rollingPolicy&gt;    &lt;!-- 此日志文档只记录ERROR级别的 --&gt;    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;        &lt;level&gt;ERROR&lt;/level&gt;        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;    &lt;/filter&gt;&lt;/appender&gt;    &lt;!--&lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、    以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，    一个可选的level和一个可选的addtivity属性。    name:用来指定受此logger约束的某一个包或者具体的某一个类。    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，          还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。          如果未设置此属性，那么当前logger将会继承上级的级别。    addtivity:是否向上级logger传递打印信息。默认是true。--&gt;    &lt;logger name=&quot;com.sxis.frs.sys.mapper&quot; level=&quot;DEBUG&quot;&gt;&lt;/logger&gt;&lt;!--    root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，    不能设置为INHERITED或者同义词NULL。默认是DEBUG    可以包含零个或多个元素，标识这个appender将会添加到这个logger。    --&gt;&lt;!-- 4. 最终的策略 --&gt;&lt;!-- 4.1 开发环境:打印控制台--&gt;&lt;springProfile&gt;    &lt;logger name=&quot;com.sxis&quot; level=&quot;debug&quot;/&gt;&lt;/springProfile&gt;&lt;root level=&quot;info&quot;&gt;    &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;    &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt;    &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt;    &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt;    &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt;&lt;/root&gt;&lt;/configuration&gt;</code></pre><p>这些配置好之后呢, 就可以在java代码中使用日志了!</p><pre><code>private static Logger log = LoggerFactory.getLogger(FreeMarkerController.class);log.info(内容);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://cczjh.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://cczjh.github.io/tags/Java/"/>
    
      <category term="Springboot" scheme="https://cczjh.github.io/tags/Springboot/"/>
    
      <category term="slf4j" scheme="https://cczjh.github.io/tags/slf4j/"/>
    
  </entry>
  
</feed>
